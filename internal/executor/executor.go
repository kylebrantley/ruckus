package executor

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/http/httptrace"
	"sync"
	"time"

	"github.com/kylebrantley/ruckus/internal/report"
)

type parser interface {
	// Run starts the parser and blocks until it is finished.
	Run()

	// Details returns the report generated by the parser.
	Details() report.Details

	// Finished returns a channel that will be closed when the parser is finished.
	Finished() <-chan bool
}

type Executor struct {
	Request          *http.Request
	RequestBody      []byte
	NumberOfRequests int // Total number of requests to make
	NumberOfThreads  int // Maximum number concurrent workers
	RequestTimeout   int

	ProcessedChannel chan bool

	results chan report.RequestResult
	stop    chan struct{}
	parser  parser
}

func New(
	request *http.Request,
	requestBody []byte,
	numberOfRequests int,
	numberOfThreads int,
	requestTimeout int,
	results chan report.RequestResult,
	parser parser,
) *Executor {
	return &Executor{
		Request:          request,
		RequestBody:      requestBody,
		NumberOfRequests: numberOfRequests,
		NumberOfThreads:  numberOfThreads,
		RequestTimeout:   requestTimeout,
		ProcessedChannel: make(chan bool, numberOfRequests),
		results:          results,
		stop:             make(chan struct{}, numberOfThreads),
		parser:           parser,
	}
}

func (e *Executor) Start() {
	go e.parser.Run()
	e.runWorkers()

	close(e.results)
	<-e.parser.Finished()
}

func (e *Executor) Stop() {
	for i := 0; i < e.NumberOfThreads; i++ {
		e.stop <- struct{}{}
	}

	close(e.results)
	close(e.stop)
}

func (e *Executor) runWorkers() {
	var wg sync.WaitGroup

	wg.Add(e.NumberOfThreads)

	client := &http.Client{
		Timeout: time.Second * time.Duration(e.RequestTimeout),
	}

	for i := 0; i < e.NumberOfThreads; i++ {
		go func() {
			e.runWorker(client, e.NumberOfRequests/e.NumberOfThreads)
			wg.Done()
		}()
	}

	wg.Wait()
}

func (e *Executor) runWorker(client *http.Client, numberOfRequests int) {
	for i := 0; i < numberOfRequests; i++ {
		select {
		case <-e.stop:
			return
		default:
			// TODO: handle error
			_ = e.executeRequest(client)
		}
	}
}

func (e *Executor) executeRequest(client *http.Client) error {
	start := time.Now()

	var dnsStart, connectionStart, responseStart, requestStart, delayStart time.Time

	var dnsDuration, connectionDuration, responseDuration, requestDuration, delayDuration time.Duration

	request := e.cloneRequest()

	trace := &httptrace.ClientTrace{
		DNSStart: func(i httptrace.DNSStartInfo) {
			dnsStart = time.Now()
		},
		DNSDone: func(info httptrace.DNSDoneInfo) {
			dnsDuration = time.Since(dnsStart)
		},
		GetConn: func(h string) {
			connectionStart = time.Now()
		},
		GotConn: func(i httptrace.GotConnInfo) {
			if !i.Reused {
				connectionDuration = time.Since(connectionStart)
			}
			requestStart = time.Now()
		},
		WroteRequest: func(i httptrace.WroteRequestInfo) {
			requestDuration = time.Since(requestStart)
			delayStart = time.Now()
		},
		GotFirstResponseByte: func() {
			delayDuration = time.Since(delayStart)
			responseStart = time.Now()
		},
	}

	request = request.WithContext(httptrace.WithClientTrace(request.Context(), trace))

	response, err := client.Do(request)
	if err != nil {
		return fmt.Errorf("request failed: %v", err)
	}

	e.ProcessedChannel <- true

	responseDuration = time.Since(responseStart)
	totalDuration := time.Since(start)
	e.results <- report.RequestResult{
		DNSDuration:        dnsDuration,
		ConnectionDuration: connectionDuration,
		ResponseDuration:   responseDuration,
		RequestDuration:    requestDuration,
		DelayDuration:      delayDuration,
		TotalDuration:      totalDuration,
		ResponseCode:       response.StatusCode,
	}

	return nil
}

func (e *Executor) cloneRequest() *http.Request {
	r2 := e.Request.Clone(context.TODO())

	if len(e.RequestBody) > 0 {
		r2.Body = io.NopCloser(bytes.NewReader(e.RequestBody))
	}

	return r2
}
